// #define DEBUG 1
/* generated by common/NeuronClass.jinja2 *//*
 *  iaf_psc_exp_wta__with_stdp_stp.cpp
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Generated from NESTML at time: 2022-09-17 19:34:29.747854
**/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "iaf_psc_exp_wta__with_stdp_stp.h"

// ---------------------------------------------------------------------------
//   Recordables map
// ---------------------------------------------------------------------------
nest::RecordablesMap<iaf_psc_exp_wta__with_stdp_stp> iaf_psc_exp_wta__with_stdp_stp::recordablesMap_;
namespace nest
{

  // Override the create() method with one call to RecordablesMap::insert_()
  // for each quantity to be recorded.
template <> void RecordablesMap<iaf_psc_exp_wta__with_stdp_stp>::create()
  {
    // add state variables to recordables map
   insert_(iaf_psc_exp_wta__with_stdp_stp_names::_V_m, &iaf_psc_exp_wta__with_stdp_stp::get_V_m);
   insert_(iaf_psc_exp_wta__with_stdp_stp_names::_rise_time_kernel__X__all_spikes, &iaf_psc_exp_wta__with_stdp_stp::get_rise_time_kernel__X__all_spikes);
   insert_(iaf_psc_exp_wta__with_stdp_stp_names::_decay_time_kernel__X__all_spikes, &iaf_psc_exp_wta__with_stdp_stp::get_decay_time_kernel__X__all_spikes);

    // Add vector variables  
  }
}

// ---------------------------------------------------------------------------
//   Default constructors defining default parameters and state
//   Note: the implementation is empty. The initialization is of variables
//   is a part of iaf_psc_exp_wta__with_stdp_stp's constructor.
// ---------------------------------------------------------------------------

iaf_psc_exp_wta__with_stdp_stp::Parameters_::Parameters_()
{
}

iaf_psc_exp_wta__with_stdp_stp::State_::State_()
{
}

// ---------------------------------------------------------------------------
//   Parameter and state extractions and manipulation functions
// ---------------------------------------------------------------------------

iaf_psc_exp_wta__with_stdp_stp::Buffers_::Buffers_(iaf_psc_exp_wta__with_stdp_stp &n):
  logger_(n)
{
  // Initialization of the remaining members is deferred to init_buffers_().
}

iaf_psc_exp_wta__with_stdp_stp::Buffers_::Buffers_(const Buffers_ &, iaf_psc_exp_wta__with_stdp_stp &n):
  logger_(n)
{
  // Initialization of the remaining members is deferred to init_buffers_().
}

// ---------------------------------------------------------------------------
//   Default constructor for node
// ---------------------------------------------------------------------------

iaf_psc_exp_wta__with_stdp_stp::iaf_psc_exp_wta__with_stdp_stp():ArchivingNode(), P_(), S_(), B_(*this)
{
  const double __resolution = nest::Time::get_resolution().get_ms();  // do not remove, this is necessary for the resolution() function
  pre_run_hook();
  // initial values for parameters
    /* generated by directives/MemberInitialization.jinja2 */ 
    P_.tau_m = 20; // as ms
    /* generated by directives/MemberInitialization.jinja2 */ 
    P_.tau_syn = 2; // as ms
    /* generated by directives/MemberInitialization.jinja2 */ 
    P_.R_max = 100; // as Hz
  // initial values for state variables
    /* generated by directives/MemberInitialization.jinja2 */ 
    S_.r = 0; // as integer
    /* generated by directives/MemberInitialization.jinja2 */ 
    S_.V_m = 0; // as mV
    /* generated by directives/MemberInitialization.jinja2 */ 
    S_.time_cnt = 0; // as integer
    /* generated by directives/MemberInitialization.jinja2 */ 
    S_.rise_time_kernel__X__all_spikes = 0; // as real
    /* generated by directives/MemberInitialization.jinja2 */ 
    S_.decay_time_kernel__X__all_spikes = 0; // as real
  recordablesMap_.create();
  // state variables for archiving state for paired synapse
  n_incoming_ = 0;
  max_delay_ = 0;
  last_spike_ = -1.;

  // cache initial values
}

// ---------------------------------------------------------------------------
//   Copy constructor for node
// ---------------------------------------------------------------------------

iaf_psc_exp_wta__with_stdp_stp::iaf_psc_exp_wta__with_stdp_stp(const iaf_psc_exp_wta__with_stdp_stp& __n):
  ArchivingNode(), P_(__n.P_), S_(__n.S_), B_(__n.B_, *this) {

  // copy parameter struct P_
  P_.tau_m = __n.P_.tau_m;
  P_.tau_syn = __n.P_.tau_syn;
  P_.R_max = __n.P_.R_max;

  // copy state struct S_
  S_.r = __n.S_.r;
  S_.V_m = __n.S_.V_m;
  S_.time_cnt = __n.S_.time_cnt;
  S_.rise_time_kernel__X__all_spikes = __n.S_.rise_time_kernel__X__all_spikes;
  S_.decay_time_kernel__X__all_spikes = __n.S_.decay_time_kernel__X__all_spikes;


  // copy internals V_
  V_.__h = __n.V_.__h;
  V_.__P__V_m__V_m = __n.V_.__P__V_m__V_m;
  V_.__P__rise_time_kernel__X__all_spikes__rise_time_kernel__X__all_spikes = __n.V_.__P__rise_time_kernel__X__all_spikes__rise_time_kernel__X__all_spikes;
  V_.__P__decay_time_kernel__X__all_spikes__decay_time_kernel__X__all_spikes = __n.V_.__P__decay_time_kernel__X__all_spikes__decay_time_kernel__X__all_spikes;
  n_incoming_ = __n.n_incoming_;
  max_delay_ = __n.max_delay_;
  last_spike_ = __n.last_spike_;

  // cache initial values
}

// ---------------------------------------------------------------------------
//   Destructor for node
// ---------------------------------------------------------------------------

iaf_psc_exp_wta__with_stdp_stp::~iaf_psc_exp_wta__with_stdp_stp()
{
}

// ---------------------------------------------------------------------------
//   Node initialization functions
// ---------------------------------------------------------------------------

void iaf_psc_exp_wta__with_stdp_stp::init_buffers_()
{
  get_all_spikes().clear(); //includes resize
  B_.logger_.reset(); // includes resize
}

void iaf_psc_exp_wta__with_stdp_stp::recompute_internal_variables(bool exclude_timestep) {
  const double __resolution = nest::Time::get_resolution().get_ms();  // do not remove, this is necessary for the resolution() function

  if (exclude_timestep) {    
      /* generated by directives/MemberInitialization.jinja2 */ 
      V_.__P__V_m__V_m = 1; // as real
      /* generated by directives/MemberInitialization.jinja2 */ 
      V_.__P__rise_time_kernel__X__all_spikes__rise_time_kernel__X__all_spikes = std::exp((-(V_.__h)) / P_.tau_syn); // as real
      /* generated by directives/MemberInitialization.jinja2 */ 
      V_.__P__decay_time_kernel__X__all_spikes__decay_time_kernel__X__all_spikes = std::exp((-(V_.__h)) / P_.tau_m); // as real
  }
  else {
    // internals V_
      /* generated by directives/MemberInitialization.jinja2 */ 
      V_.__h = __resolution; // as ms
      /* generated by directives/MemberInitialization.jinja2 */ 
      V_.__P__V_m__V_m = 1; // as real
      /* generated by directives/MemberInitialization.jinja2 */ 
      V_.__P__rise_time_kernel__X__all_spikes__rise_time_kernel__X__all_spikes = std::exp((-(V_.__h)) / P_.tau_syn); // as real
      /* generated by directives/MemberInitialization.jinja2 */ 
      V_.__P__decay_time_kernel__X__all_spikes__decay_time_kernel__X__all_spikes = std::exp((-(V_.__h)) / P_.tau_m); // as real
  }
}
void iaf_psc_exp_wta__with_stdp_stp::pre_run_hook() {
  B_.logger_.init();

  recompute_internal_variables();

  // buffers B_
}

// ---------------------------------------------------------------------------
//   Update and spike handling functions
// ---------------------------------------------------------------------------
void iaf_psc_exp_wta__with_stdp_stp::evolve_weights( nest::Time const & origin, const long lag )
{
    /**
    **/
    // TODO this is static for now, change!
    double eta = 0.05 / (origin.get_steps() + 1);  // +1 is needed for consistency with Klampfl
    for (auto& it : V_.activeSources)
    {
        double w = V_.localWeights_Wk[it];  // this should be negative - same sign as in Klampfl
        double P = std::exp(w);
        double truncP = std::max(P, eta);

        double dw = (V_.yt_epsp_traces[it] - P) / truncP;

        V_.localWeights_Wk[it] += eta * dw;

        std::cout << "Evolved w_ik for " << it << " -> " << get_node_id() << " = " << V_.localWeights_Wk[it]
                  << " from y(t) = " << V_.yt_epsp_traces[it]
                  << std::endl << std::flush;
    }
}

void iaf_psc_exp_wta__with_stdp_stp::evolve_epsps( nest::Time const & origin, const long lag )
{
    /**
    Computes the current voltage u(t) as per equation (1). Following this, we evolve the unweighted,
    but STP scaled EPSPs to get y_i(t) for each presynaptic neuron - this is used in the next step then.
    **/
    std::ostringstream msg;

    double u_t = 0;
    const double resolution = nest::Time::get_resolution().get_ms();  // do not remove, this is necessary for the resolution() function

    for (auto& it : V_.activeSources)
    {
        // iterate over each presyn index i and compute the weighted y_i(t) for the current time step
        V_.yt_epsp_traces[it] = V_.yt_epsp_decay[it] - V_.yt_epsp_rise[it];  // == self.Y
        u_t += V_.localWeights_Wk[it] * V_.yt_epsp_traces[it];  // add to sum after weighting with w_ki(t)

        // iterate over each presyn index and evolve rise and decay EPSP terms
        // TODO this are the exact solutions, but use lame numerics as in Klampfl
//        V_.yt_epsp_decay[it] *= V_.__P__decay_time_kernel__X__all_spikes__decay_time_kernel__X__all_spikes;
//        V_.yt_epsp_rise[it] *= V_.__P__rise_time_kernel__X__all_spikes__rise_time_kernel__X__all_spikes;
        // TODO this appears to be crucial for similar results!
        V_.yt_epsp_decay[it] -= V_.yt_epsp_decay[it] * resolution / P_.tau_m;
        V_.yt_epsp_rise[it] -= V_.yt_epsp_rise[it] * resolution / P_.tau_syn;

        std::cout << "[epsp] evolved EPSP " << V_.yt_epsp_decay[it] << "\t" << V_.yt_epsp_rise[it]
                    << " ==> Y(t) = " << V_.yt_epsp_traces[it]
                    << "\n" << std::flush;
    }
    S_.V_m = u_t;  // set V_m to current value of u(t)

    // evolve synaptic activations s_ij, i.e., process any spikes and add corresponding scaled delta impulses
//    msg << "[update] iterating over spike events... \n";
    for (auto it = V_.spikeEvents.begin(); it != V_.spikeEvents.end();)
    {
        std::cout << "[update] spike from source " << it->id_ << ", scheduled @ " << it->deliveryTime
            << "; origin: " << origin.get_steps() << "; lag: " << lag << "\n" << std::flush;
        if (it->deliveryTime + 1 == origin.get_steps() + lag)
        {
            V_.yt_epsp_decay[it->id_] += V_.preSynWeights[it->id_];
            V_.yt_epsp_rise[it->id_] += V_.preSynWeights[it->id_];
            it = V_.spikeEvents.erase(it);
        }
        else
        {
            ++it;
        }
    }
}


void iaf_psc_exp_wta__with_stdp_stp::update(nest::Time const & origin,const long from, const long to)
{
  const double __resolution = nest::Time::get_resolution().get_ms();  // do not remove, this is necessary for the resolution() function
  double __t = 0;
  std::ostringstream msg;
//  std::cout << S_.V_m << std::endl;

  for ( long lag = from ; lag < to ; ++lag )
  {
        std::cout << "//////////////\nfrom " << from << " to " << to << ", lag = " << lag
                  << " @origin: " << origin.get_steps() << "\n" << std::flush;
        B_.all_spikes_grid_sum_ = get_all_spikes().get_value(lag);
//        std::cout << "all_spikes_grid_sum_ = " << B_.all_spikes_grid_sum_ << "\n" << std::flush;

        evolve_epsps(origin, lag);
        // NESTML generated code for the update block:/* generated by directives/Block.jinja2 */ /* generated by directives/Statement.jinja2 */ /* generated by directives/SmallStatement.jinja2 */ /* generated by directives/FunctionCall.jinja2 */ /* generated by directives/AnalyticIntegrationStep_begin.jinja2 */
    //  double V_m__tmp = get_V_m() * V_.__P__V_m__V_m;
    //  double rise_time_kernel__X__all_spikes__tmp = V_.__P__rise_time_kernel__X__all_spikes__rise_time_kernel__X__all_spikes * get_rise_time_kernel__X__all_spikes();
    //  double decay_time_kernel__X__all_spikes__tmp = V_.__P__decay_time_kernel__X__all_spikes__decay_time_kernel__X__all_spikes * get_decay_time_kernel__X__all_spikes();
    //  /* replace analytically solvable variables with precisely integrated values  *//* generated by directives/AnalyticIntegrationStep_end.jinja2 */
    //  S_.V_m = V_m__tmp;
    //  S_.rise_time_kernel__X__all_spikes = rise_time_kernel__X__all_spikes__tmp;
    //  S_.decay_time_kernel__X__all_spikes = decay_time_kernel__X__all_spikes__tmp;/* generated by directives/ApplySpikesFromBuffers.jinja2 */ /* generated by directives/Assignment.jinja2 */
    //
    //  S_.rise_time_kernel__X__all_spikes += (B_.all_spikes_grid_sum_) / (1.0);/* generated by directives/Assignment.jinja2 */
    //  S_.decay_time_kernel__X__all_spikes += (B_.all_spikes_grid_sum_) / (1.0);/* generated by directives/Statement.jinja2 */ /* generated by directives/SmallStatement.jinja2 */ /* generated by directives/Assignment.jinja2 */

      S_.time_cnt += 1;/* generated by directives/Statement.jinja2 */ /* generated by directives/SmallStatement.jinja2 */ /* generated by directives/Assignment.jinja2 */
//      S_.V_m = get_y() * 1.0;/* generated by directives/Statement.jinja2 */ /* generated by directives/SmallStatement.jinja2 */ /* generated by directives/Declaration.jinja2 */
    //  std::cout << S_.V_m << std::endl;
      double rate = P_.R_max * std::exp(get_V_m() / 1.0);/* generated by directives/Statement.jinja2 */ /* generated by directives/SmallStatement.jinja2 */ /* generated by directives/Declaration.jinja2 */
      double p = __resolution * rate / 1000;/* generated by directives/Statement.jinja2 */ /* generated by directives/CompoundStatement.jinja2 */ /* generated by directives/IfStatement.jinja2 */

      if (((0) + (1) * nest::get_vp_specific_rng( get_thread() )->drand())<=p)
      {/* generated by directives/Block.jinja2 */ /* generated by directives/Statement.jinja2 */ /* generated by directives/SmallStatement.jinja2 */ /* generated by directives/Assignment.jinja2 */
          p = 1;
      }/* generated by directives/Statement.jinja2 */ /* generated by directives/CompoundStatement.jinja2 */ /* generated by directives/IfStatement.jinja2 */

      if (get_time_cnt()==15||get_time_cnt()==500)
      {/* generated by directives/Block.jinja2 */ /* generated by directives/Statement.jinja2 */ /* generated by directives/SmallStatement.jinja2 */ /* generated by directives/FunctionCall.jinja2 */
          set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
          nest::SpikeEvent se;
          nest::kernel().event_delivery_manager.send(*this, se, lag);

          evolve_weights(origin, lag);
      }

        // voltage logging
        B_.logger_.record_data(origin.get_steps() + lag);
  }
}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void iaf_psc_exp_wta__with_stdp_stp::handle(nest::DataLoggingRequest& e)
{
  B_.logger_.handle(e);
}

void iaf_psc_exp_wta__with_stdp_stp::handle(nest::SpikeEvent &e)
{
  assert(e.get_delay_steps() > 0);
  const double weight = e.get_weight();
  const double multiplicity = e.get_multiplicity();

//    get_all_spikes().
//        add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
//                       weight * multiplicity );
    long deliveryTime = e.get_rel_delivery_steps(nest::kernel().simulation_manager.get_slice_origin());

//    std::ostringstream msg;
    std::cout << "\n\t\tweight: " << weight
        << "\n\t\t sender id: " << e.get_sender().get_node_id()
        << "\n\t\t TIME: (event tstamp) " << e.get_stamp().get_steps()
        << "\n\t\t slice_origin(): " << nest::kernel().simulation_manager.get_slice_origin()
        << "\n\t\t get_delay_steps(): " << e.get_delay_steps()
        << "\n\t\t deliveryTime: " << deliveryTime
        << "\n\t\t absolut deliveryTime (! precise): " << e.get_stamp().get_steps() + e.get_delay_steps() - 2
        << "\n" << std::flush;
//    const double fixed_weight_epsp = 1;
    TraceTracker_ spikeEventStruct = {e.get_stamp().get_steps() + e.get_delay_steps() - 2,
                                      weight, e.get_sender().get_node_id(), 0, false, true};

    V_.spikeEvents.push_back(spikeEventStruct);
    V_.preSynWeights[e.get_sender().get_node_id()] = weight;  // this just takes into account the STP part TODO revert
    V_.preSynWeights[e.get_sender().get_node_id()] = 1.;  // this just takes into account the STP part
    V_.activeSources.insert(e.get_sender().get_node_id());
    get_all_spikes().add_value(deliveryTime, weight * multiplicity);
}


inline double
iaf_psc_exp_wta__with_stdp_stp::get_spiketime_ms() const
{
  return last_spike_;
}


void
iaf_psc_exp_wta__with_stdp_stp::register_stdp_connection( double t_first_read, double delay )
{
  // Mark all entries in the deque, which we will not read in future as read by
  // this input input, so that we safely increment the incoming number of
  // connections afterwards without leaving spikes in the history.
  // For details see bug #218. MH 08-04-22

  for ( std::deque< histentry__iaf_psc_exp_wta__with_stdp_stp >::iterator runner = history_.begin();
        runner != history_.end() and ( t_first_read - runner->t_ > -1.0 * nest::kernel().connection_manager.get_stdp_eps() );
        ++runner )
  {
    ( runner->access_counter_ )++;
  }

  n_incoming_++;

  max_delay_ = std::max( delay, max_delay_ );
}


void
iaf_psc_exp_wta__with_stdp_stp::get_history__( double t1,
  double t2,
  std::deque< histentry__iaf_psc_exp_wta__with_stdp_stp >::iterator* start,
  std::deque< histentry__iaf_psc_exp_wta__with_stdp_stp >::iterator* finish )
{
  *finish = history_.end();
  if ( history_.empty() )
  {
    *start = *finish;
    return;
  }
  std::deque< histentry__iaf_psc_exp_wta__with_stdp_stp >::reverse_iterator runner = history_.rbegin();
  const double t2_lim = t2 + nest::kernel().connection_manager.get_stdp_eps();
  const double t1_lim = t1 + nest::kernel().connection_manager.get_stdp_eps();
  while ( runner != history_.rend() and runner->t_ >= t2_lim )
  {
    ++runner;
  }
  *finish = runner.base();
  while ( runner != history_.rend() and runner->t_ >= t1_lim )
  {
    runner->access_counter_++;
    ++runner;
  }
  *start = runner.base();
}

void
iaf_psc_exp_wta__with_stdp_stp::set_spiketime( nest::Time const& t_sp, double offset )
{
    ArchivingNode::set_spiketime( t_sp, offset );

    unsigned int num_transferred_variables = 0;

    const double t_sp_ms = t_sp.get_ms() - offset;

    if ( n_incoming_ )
    {
        // prune all spikes from history which are no longer needed
        // only remove a spike if:
        // - its access counter indicates it has been read out by all connected
        //     STDP synapses, and
        // - there is another, later spike, that is strictly more than
        //     (max_delay_ + eps) away from the new spike (at t_sp_ms)
        while ( history_.size() > 1 )
        {
            const double next_t_sp = history_[ 1 ].t_;
            if ( history_.front().access_counter_ >= n_incoming_ * num_transferred_variables
                and t_sp_ms - next_t_sp > max_delay_ + nest::kernel().connection_manager.get_stdp_eps() )
            {
                history_.pop_front();
            }
            else
            {
                break;
            }
        }

        if (history_.size() > 0) {
            assert(history_.back().t_ == last_spike_);
        }
        else {
        }


        /**
         * update state variables transferred from synapse from `last_spike_` to `t_sp_ms`
        **/

        const double old___h = V_.__h;
        V_.__h = t_sp_ms - last_spike_;
        if (V_.__h > 1E-12) {
          recompute_internal_variables(true);
      /* generated by directives/AnalyticIntegrationStep_begin.jinja2 */ 
      /* replace analytically solvable variables with precisely integrated values  *//* generated by directives/AnalyticIntegrationStep_end.jinja2 */ 
        V_.__h = old___h;
        recompute_internal_variables(true);
      }

        /**
         * apply spike updates
        **/

    last_spike_ = t_sp_ms;
    history_.push_back( histentry__iaf_psc_exp_wta__with_stdp_stp( last_spike_
, 0
 ) );
  }
  else
  {
    last_spike_ = t_sp_ms;
  }
}


void
iaf_psc_exp_wta__with_stdp_stp::clear_history()
{
  last_spike_ = -1.0;
  history_.clear();
}



